
# -*- coding: utf-8 -*-
"""WindTurbine MTP2_Perfromance_Scipy.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FTNdQpQnVzjTpDvcJuWbvhxia6r4aRiG
"""
from mayavi import mlab
import numba
import time
import numpy as np
import sympy as sp  # importing numpy library as sp
from math import *
import matplotlib.pyplot as plt

Start_time = time.time()

L_ig = sp.Symbol('lambda_ig')  # declaring symbol lambda_ig
L_i = sp.Symbol('lambda_i')


# %%
@numba.njit
def Rotate(x2, y2, theta):
    X = (x2 * np.cos(theta) - y2 * np.sin(theta)) + X_displacement
    Y = (x2 * np.sin(theta) + y2 * np.cos(theta)) + Y_displacement
    return X, Y


def Distance(x1, y1, z1, x2, y2, z2):
    dis = sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2 + (z1 - z2) ** 2)
    return dis


alp = 1.2
K_visc = 0.000015
del_s = 1000


def LAMBDA_I(r_in, psi_in, L_ig_in, mu_in):
    LHS = (L_i) / (L_ig_in)  # LHS
    RHS = 1 + ((1.333 * mu_in) / (1.2 * (L_i + L_ig_in) + mu_in)) * ((r_in * cos(psi_in)) / R_tip)  # RHS
    function = LHS - RHS  # funtion equated to 0
    diff_function = function.diff(L_i)  # differentiation of equation
    h1 = sp.lambdify(L_i, function)  # defines value of L_i in  equation
    h2 = sp.lambdify(L_i, diff_function)  # defines value of L_i  in differentiated  equation
    inr = 0
    difference = 1  # initial guess for  Newton-Raphson method
    while difference > 0.001:
        h = (-1 * h1(inr) / h2(inr))  # h= -f(x)/df(x)
        difference = abs(h)
        inr = inr + h  # Xi= X(i-1)+h
    L_i_calculated = inr  # calculated value of L_i (inflow ratio) at given radial location
    return L_i_calculated
#%%
def Rotate_for_plot(x2, y2, theta):
    X = (x2 * np.cos(theta) - y2 * np.sin(theta))
    Y = (x2 * np.sin(theta) + y2 * np.cos(theta))
    return X,Y

# %%
@numba.njit
def Biot_Savarts_Law2(Positions, trail_circulation,shed_circulation, b, IM_in,V_ind):

    for j in range(Far_feild_cutoff):
        xc = Positions[j][IM_in][0][b]
        yc = Positions[j][IM_in][1][b]
        zc = Positions[j][IM_in][2][b]
        for bl in range(1, blades + 1):
            for i in range(IM):
                for k in range(0, JM - 1):
                    if k != j and (k + 1) != (j+1):
                        d_gamma = (trail_circulation[k][i][bl - 1])
                        xa = Positions[k][i][0][bl - 1]
                        xb = Positions[k + 1][i][0][bl - 1]

                        ya = Positions[k][i][1][bl - 1]
                        yb = Positions[k + 1][i][1][bl - 1]

                        za = Positions[k][i][2][bl - 1]
                        zb = Positions[k + 1][i][2][bl - 1]

                        V_induced = np.zeros(3)
                        L = ((xa - xb) ** 2 + (ya - yb) ** 2 + (za - zb) ** 2) ** 0.5

                        cutoff = sqrt((0.25 * L) ** 4 + 4 * alp * del_s * K_visc * ((k + 1) * dpsi / omega))
                        r1 = ((xc - xa) ** 2 + (yc - ya) ** 2 + (zc - za) ** 2) ** 0.5 + cutoff
                        r2 = ((xc - xb) ** 2 + (yc - yb) ** 2 + (zc - zb) ** 2) ** 0.5 + cutoff


                        TERM1 = d_gamma * (r1 + r2) / (2 * pi * (r1) * (r2) * ((r1 + r2) ** 2 - L ** 2))
                        u_bs = TERM1 * ((zc - zb) * (yb - ya) - (yc - yb) * (zb - za))
                        v_bs = TERM1 * ((xc - xb) * (zb - za) - (zc - zb) * (xb - xa))
                        w_bs = TERM1 * ((yc - yb) * (xb - xa) - (xc - xb) * (yb - ya))

                        if bl > Blades_per_turbine:
                            u_bs = -1 * u_bs
                            v_bs = -1 * v_bs
                            w_bs = -1 * w_bs

                        V_induced[0] = u_bs
                        V_induced[1] = v_bs
                        V_induced[2] = w_bs

                        V_add = V_induced  #

                    else:
                        V_add = np.zeros(3)
                    V_ind[j, :] = V_ind[j, :] + V_add




    # for j in range(Far_feild_cutoff):
    #     xc = Positions[j][IM_in][0][b]
    #     yc = Positions[j][IM_in][1][b]
    #     zc = Positions[j][IM_in][2][b]
    #     for bl in range(1, blades + 1):
    #         for k in range(1, JM):
    #             for i in range(IM-1):
    #                 if k != j and (k + 1) != (j + 1):
    #                     d_gamma = (shed_circulation[k][i][bl - 1])
    #
    #                     xa = Positions[k][i][0][bl - 1]
    #                     xb = Positions[k][i+1][0][bl - 1]
    #
    #                     ya = Positions[k][i][1][bl - 1]
    #                     yb = Positions[k][i+1][1][bl - 1]
    #
    #                     za = Positions[k][i][2][bl - 1]
    #                     zb = Positions[k][i+1][2][bl - 1]
    #
    #                     V_induced = np.zeros(3)
    #                     L = ((xa - xb) ** 2 + (ya - yb) ** 2 + (za - zb) ** 2) ** 0.5
    #
    #                     cutoff = sqrt((0.25 * L) ** 4 + 4 * alp * del_s * K_visc * ((k + 1) * dpsi / omega))
    #                     r1 = ((xc - xa) ** 2 + (yc - ya) ** 2 + (zc - za) ** 2) ** 0.5 + cutoff
    #                     r2 = ((xc - xb) ** 2 + (yc - yb) ** 2 + (zc - zb) ** 2) ** 0.5 + cutoff
    #
    #                     TERM1 = d_gamma * (r1 + r2) / (2 * pi * (r1) * (r2) * ((r1 + r2) ** 2 - L ** 2))
    #                     u_bs = TERM1 * ((zc - zb) * (yb - ya) - (yc - yb) * (zb - za))
    #                     v_bs = TERM1 * ((xc - xb) * (zb - za) - (zc - zb) * (xb - xa))
    #                     w_bs = TERM1 * ((yc - yb) * (xb - xa) - (xc - xb) * (yb - ya))
    #
    #                     if bl > Blades_per_turbine:
    #                         u_bs = -1 * u_bs
    #                         v_bs = -1 * v_bs
    #                         w_bs = -1 * w_bs
    #
    #                     V_induced[0] = u_bs
    #                     V_induced[1] = v_bs
    #                     V_induced[2] = w_bs
    #                 else:
    #                     V_add = np.zeros(3)
    #                 V_add = V_induced
    #                 V_ind[j, :] = V_ind[j, :] + V_add

    for rot in range(NR_F):
        V_ind[Far_feild_cutoff+N*rot:Far_feild_cutoff+N*(rot+1), :]= V_ind[Far_feild_cutoff-N:Far_feild_cutoff, :]

    return V_ind


# %%
@numba.njit
def Biot_Savarts_Perfromance(Positions, trail_circulation,shed_circulation, b, IM_in,V_ind):  # recheck this part for

    xc = Positions[0][IM_in][0][b]
    yc = Positions[0][IM_in][1][b]
    zc = Positions[0][IM_in][2][b]

    for bl in range(1, blades + 1):
        for i in range(IM):
            for k in range(0, JM-1):
                d_gamma = (trail_circulation[k][i][bl - 1])
                xa = Positions[k][i][0][bl - 1]
                xb = Positions[k + 1][i][0][bl - 1]

                ya = Positions[k][i][1][bl - 1]
                yb = Positions[k + 1][i][1][bl - 1]

                za = Positions[k][i][2][bl - 1]
                zb = Positions[k + 1][i][2][bl - 1]

                V_induced = np.zeros(3)
                L = ((xa - xb) ** 2 + (ya - yb) ** 2 + (za - zb) ** 2) ** 0.5

                cutoff = sqrt((0.25 * L) ** 4 + 4 * alp * del_s * K_visc * ((k + 1) * dpsi / omega))
                r1 = ((xc - xa) ** 2 + (yc - ya) ** 2 + (zc - za) ** 2) ** 0.5 + cutoff
                r2 = ((xc - xb) ** 2 + (yc - yb) ** 2 + (zc - zb) ** 2) ** 0.5 + cutoff

                TERM1 = d_gamma * (r1 + r2) / (2 * pi * (r1) * (r2) * ((r1 + r2) ** 2 - L ** 2))
                u_bs = TERM1 * ((zc - zb) * (yb - ya) - (yc - yb) * (zb - za))
                v_bs = TERM1 * ((xc - xb) * (zb - za) - (zc - zb) * (xb - xa))
                w_bs = TERM1 * ((yc - yb) * (xb - xa) - (xc - xb) * (yb - ya))
                if bl > Blades_per_turbine:
                    u_bs = -1 * u_bs
                    v_bs = -1 * v_bs
                    w_bs = -1 * w_bs


                V_induced[0] = u_bs
                V_induced[1] = v_bs
                V_induced[2] = w_bs

                V_add = V_induced  #
                V_ind[:] = V_ind[:] + V_add


        # for k in range(0,JM ):
        #     for i in range(IM):
        #         d_gamma = (shed_circulation[k][i][bl - 1])
        #
        #         xa = Positions[k][i][0][bl - 1]
        #         xb = Positions[k ][i+ 1][0][bl - 1]
        #
        #         ya = Positions[k][i][1][bl - 1]
        #         yb = Positions[k ][i+ 1][1][bl - 1]
        #
        #         za = Positions[k][i][2][bl - 1]
        #         zb = Positions[k ][i+ 1][2][bl - 1]
        #
        #
        #         V_induced = np.zeros(3)
        #         L = ((xa - xb) ** 2 + (ya - yb) ** 2 + (za - zb) ** 2) ** 0.5
        #
        #         cutoff = sqrt((0.25 * L) ** 4 + 4 * alp * del_s * K_visc * ((k + 1) * dpsi / omega))
        #         r1 = ((xc - xa) ** 2 + (yc - ya) ** 2 + (zc - za) ** 2) ** 0.5 + cutoff
        #         r2 = ((xc - xb) ** 2 + (yc - yb) ** 2 + (zc - zb) ** 2) ** 0.5 + cutoff
        #
        #
        #
        #         TERM1 = d_gamma * (r1 + r2) / (2 * pi * (r1) * (r2) * ((r1 + r2) ** 2 - L ** 2))
        #         u_bs = TERM1 * ((zc - zb) * (yb - ya) - (yc - yb) * (zb - za))
        #         v_bs = TERM1 * ((xc - xb) * (zb - za) - (zc - zb) * (xb - xa))
        #         w_bs = TERM1 * ((yc - yb) * (xb - xa) - (xc - xb) * (yb - ya))
        #         if bl > Blades_per_turbine:
        #             u_bs = -1 * u_bs
        #             v_bs = -1 * v_bs
        #             w_bs = -1 * w_bs
        #
        #         V_induced[0] = u_bs
        #         V_induced[1] = v_bs
        #         V_induced[2] = w_bs
        #
        #         V_add = V_induced  #
        #         V_ind[:] = V_ind[:] + V_add



    return V_ind
# %%
N=24# number of divisions in blade span also in one revolution
NR =7
NR_F=2
mu=0.0
alpha_d =0# assuming Tip path plane
alpha = alpha_d * (pi / 180)
alpha_p= -1*alpha
print("Tip path plane: ", alpha_d)
R_tip = 5.5
R_hub = 0.1 * R_tip
Far_feild_cutoff=int((NR-NR_F)*N)
RPM = 383  # rpm of rotor at criuse
omega = (2 * pi * RPM) / 60
N_count = 50
Vv = 0  # tip path plane in radians
u_inf =mu *(omega * R_tip)/ cos(alpha)# this is Y direction
v_inf = 0  # this is X direction
w_inf = 0 - u_inf * sin(alpha) - Vv
V_vec = [v_inf, u_inf, w_inf]
print("U_inf",u_inf)
IM =9+ 1
a = 5.75    # lift curve slope per radian from literature
Cdo = 0.022  # co-efficient of drag from literature
b =2
Number_of_rotors =1
Blades_per_turbine = b / Number_of_rotors
blades = b  # number of blades1
# tip path plane in radians                                                                 #increment of azimuthal angle
rho = 1.225  # density of air
chord_hub = 0.325 # chord at root cut out                                                                #tip radius
R_tip = 5.5
R_hub = 0.1 * R_tip
span = R_tip - R_hub
Z_displacement = 0.2* R_tip
X_displacement = 1.5* R_tip # longitudunal
Y_displacement = 0* R_tip # lateral
h_by_r=0 # for ground effect

dr = span / (IM - 1)
radius = np.linspace(R_hub, R_tip, IM)
D = 2 * R_tip  # blade diameter
Overlapp_Area=0
d= sqrt(X_displacement**2+Y_displacement**2)
if d > 2*R_tip:
    d= 2*R_tip
h_by_r=0 # for ground effect
Overlapp_Area= 2*R_tip**2*(acos(d/(2*R_tip))) -0.5*sqrt((4*R_tip**2-d**2)*d**2)
if Number_of_rotors >1:
    Disc_Area= pi*R_tip**2*Number_of_rotors- (Overlapp_Area)
else:
    Disc_Area = pi * R_tip ** 2 * Number_of_rotors

print("Area", round(pi*R_tip**2,3))
print("Overlap Area:",round(Overlapp_Area,3))
print("Effective Disc Area:",round(Disc_Area,3))

taper_ratio = 1  # taper ratio
chord_tip = chord_hub * taper_ratio  # chord at blade tip
taper_slope = (chord_tip - chord_hub) / (R_tip - R_hub)  # term T
chord_root = chord_hub - taper_slope * R_hub  # chord at root

chord = chord_root + taper_slope * radius

theta_tip =2 # twist at tip of blade
theta_hub = 12  # twist atroot cut out
F = (theta_tip - theta_hub) / (R_tip - R_hub)  # term F
E = theta_hub - F * R_hub  # term E
mu = (u_inf * cos(alpha)) / (omega * R_tip)  # advance ratio
lc = (Vv / (omega * R_tip))

# print("Theoretical thrust(N):",T)
blade_twist = (theta_tip - theta_hub) * (pi / 180)  # radians
theta = (E + F * radius) * (pi / 180)  #
solidity = (Blades_per_turbine * chord) / (pi * R_tip)
dt = (60 / RPM) * (1 / N)  # dpsi

rad_sec = (2 * pi * RPM) / 60
dpsi_d = (360 / N)

dpsi = dpsi_d * (pi / 180)
NT = (NR * (360)) / dpsi_d
T = NT * dt
JM = int(NT)
# print("Coefficient of thrust ", CT)
print("JM is", JM, "  IM is", IM, ",dpsi:", round(dpsi * 180 / pi, 2), "twist", blade_twist * (180 / pi), "NR ", NR)
print("Advance ratio:", mu)
print("Tip Speed (m/s):", omega * R_tip)
beta = 0

wake_age_array = np.linspace(0, JM * dpsi * 180 / pi, JM)
V_INF = np.zeros((JM, 3))
for i in range(3):
    for j in range(JM):
        V_INF[j, i] = V_vec[i]

psi_array = np.linspace(0, 2 * pi, N)

# %%

location = R_hub  # location of blade root cut out
PTC_inflow_array = np.zeros(IM) # array to store inflow ratio after solving Prantl's tip loss model
location_array = []
for i in range(IM):  # loop for elemental radial location
    dif = 1  # to start loop a initail diffferece is provided
    lmd_1 = 1  # initial guess values for inflow ratio
    while dif > 0.001:  # to iterate till the difference is in order of 0.0001
        f = 0.5 * Blades_per_turbine * (1 - (radius[i] / R_tip)) / lmd_1  # f term  of  Prantl's tip loss model
        if f < 0.00001:
            FL = (2 / pi) * acos(e ** (-1 * 0.00001))
        else:
            FL = (2 / pi) * acos(e ** (-1 * f))  # F term of  Prantl's tip loss model
        lmd_2 = np.sqrt((((a * solidity[i]) / (16 * FL)) - 0.5 * lc) ** (2) + ((solidity[i] * a * theta[i] * radius[i]) / (FL * 8 * R_tip))) - (((a * solidity[i]) / (16 * FL)) - 0.5 * lc)
        dif = abs(lmd_1 - lmd_2)  # checking difference
        lmd_1 = lmd_2  # assigning new inflow ratio value
    PTC_inflow_array[i]=lmd_1  # filling up the  PTC_inflow_array array

phi_array = np.arctan(PTC_inflow_array * (R_tip / radius))
alpha_array = theta - phi_array
Cd_array = Cdo + 1.25 * (alpha_array) ** 2
Cl_array = a * (alpha_array)
circulation = 0.5 * (omega * radius + u_inf * cos(alpha) * sin(pi / 2)) * chord * Cl_array
circulation_old = circulation

gamma_max = max(circulation)

# %%
# Thrust2 CALCULATION and power calculation
Thrust2_array = np.zeros(IM)
Power2_array = np.zeros(IM)
UP_array = np.zeros(IM)
T_a = 0.5 * rho * Blades_per_turbine  # constant part in thrust equation
Ut = omega * radius  # tangential velocity
Up_array = PTC_inflow_array * omega * R_tip  # perpendicular velocity
Cd = Cdo + 1.25 * np.square(alpha_array) # drag equation in terms of r
Cl = a * alpha_array  # lift equation   in terms of r
dT = 0.5 * rho * Blades_per_turbine * (np.square(Up_array)  + np.square(Ut) ) * chord * (Cl * np.cos(phi_array) - Cd * np.sin(phi_array))
dP = 0.5 * rho * Blades_per_turbine * omega * radius * (np.square(Up_array)  + np.square(Ut)) * chord * (Cd * np.cos(phi_array) + Cl * np.sin(phi_array))
Thrust =    Number_of_rotors* np.trapz(dT, radius) / cos(alpha)
Power =    Number_of_rotors*np.trapz(dP, radius) / cos(alpha)
CT_A1 = Thrust / (rho * Disc_Area * (omega * R_tip) ** 2)  # Thrust co efficient #""";
CP = Power / (rho * Disc_Area * (omega * R_tip) ** 3)  # Thrust co efficient #""";
circulation_A1= 0.5*Cl*chord*Ut

# %%

CT_A1 = Thrust / (rho * Disc_Area * (omega * R_tip) ** 2)
LHS = CT_A1 /Number_of_rotors
RHS = 2 * L_ig * sp.sqrt(mu ** 2 + (mu * tan(abs(alpha)) + L_ig) ** 2)
function = LHS - RHS
diff_function = function.diff(L_ig)  # differentiation of equation
h1 = sp.lambdify(L_ig, function)  # defines value of L_ig in  equation
h2 = sp.lambdify(L_ig, diff_function)  # defines value of L_ig in differentiated  equation
il = 0.01  # initial guess for  Newton-Raphson method
for j in range(1000):  # Newton-Raphson method
    h = (-1 * h1(il) / h2(il))  # h= -f(x)/df(x)
    il = il + h  # Xi= X(i-1)+h
L_ig_calculated = il  # calculated value of L_ig
LG = (L_ig_calculated + L_i)
# Thrust2 CALCULATION and power calculation
#  below mentioned are the arrays to store the velues of function to calculate T, P,Q ,Overall rolling and pitching moments at each azimuthal location
dOPM_array = np.zeros(N)
dORM_array = np.zeros(N)
dT_blade_array = np.zeros(N)
dOQi_array = np.zeros(N)
dOQo_array = np.zeros(N)
dT_array = np.zeros(N)
dOPi_array = np.zeros(N)
dOPo_array = np.zeros(N)
dbeta_dt = 0  # TPP as a reference frame
beta_o_d = 0  # TPP frame of reference # beta   in degrees
beta_1s_d = 0  # beta_1s kept 0 or as pilot input in degrees
beta_1c_d = 0  # beta_1c kept 0 pilot input  degrees
theta_1s = (0) * (pi / 180)  # theta_1s  in degrees at trim conditio
theta_1c = (0) * (pi / 180)  # theta_1c  in degrees at trim conditio
Thrust_plot_array= np.zeros((N+1,IM))
circulation= np.zeros((JM,IM))
Up_BEM_array= np.zeros((N,IM))
for j in range(N):

    beta = (beta_o_d + beta_1c_d * cos(j*dpsi) + beta_1s_d * sin(j*dpsi)) * (pi / 180)  # beta

    # arrays to store sectional Lift,  induced & profile Torque ,induced & profile Power at each radial location
    dL_array = np.zeros(IM)
    dP_array = np.zeros(IM)
    dR_array = np.zeros(IM)
    dQi_array = np.zeros(IM)
    dQo_array = np.zeros(IM)
    dPi_array = np.zeros(IM)
    dPo_array = np.zeros(IM)
    for i in range(IM):  # loop to solve the dL,dQi,dQo,dPi,dPo, dPM, dRM
        LHS = (L_i) / (L_ig_calculated)  # LHS
        RHS = 1 + ((1.333 * mu) / (1.2 * (L_i + L_ig_calculated) + mu)) * ((radius[i] * cos(j*dpsi)) / R_tip)  # RHS
        function = LHS - RHS  # funtion equated to 0
        diff_function = function.diff(L_i)  # differentiation of equation
        h1 = sp.lambdify(L_i, function)  # defines value of L_i in  equation
        h2 = sp.lambdify(L_i, diff_function)  # defines value of L_i  in differentiated  equation
        inr = 0
        difference = 1  # initial guess for  Newton-Raphson method
        while difference > 0.001:
            h = (-1 * h1(inr) / h2(inr))  # h= -f(x)/df(x)
            difference = abs(h)
            inr = inr + h  # Xi= X(i-1)+h
        L_i_calculated = inr  # calculated value of L_i (inflow ratio) at given radial location

        theta_equation = (theta[i] + theta_1c * cos(j*dpsi) + theta_1s * sin(j*dpsi))  # theta in tersm of r i.e. theta_twd=E+Fr

        Up = u_inf * sin((alpha)) + (omega * R_tip * (L_i_calculated)+Vv) + radius[i] * dbeta_dt + u_inf * sin(beta) * cos(j*dpsi)  # Up
        Ut = omega * radius[i] + u_inf * cos(alpha) * sin(j*dpsi)
        Up_BEM_array[j][i] = Up
        dL_array[i] = (0.5 * rho * chord[i] * a * (theta_equation * Ut ** 2 - Ut * Up))  # filling the  corresponding array
        dP_array[i] = dL_array[i] * radius[i] * cos(j*dpsi)  # filling the  corresponding array

        dR_array[i] = dL_array[i] * radius[i] * sin(j*dpsi)  # filling the  corresponding array

        dDi =  0.5 * rho * chord[i] * a * (theta_equation - atan(Up / Ut)) * Up * Ut  # Di term in induced torque equation
        dQi_array[i] = dDi * radius[i]  # filling the  corresponding array

        dDo = 0.5 * rho * Ut * Ut * chord[i] * (Cdo)  # Do term in  profile torque equation
        dQo_array[i] = dDo * radius[i]  # filling the  corresponding array

        dPi_array[i] = dDi * Ut  # filling the  corresponding array
        dPo_array[i] = dDo * Ut  # filling the  corresponding array

        Thrust_plot_array[j][i]=dL_array[i]
        circulation[j][i]= (dL_array[i])/(rho*Ut)


    dT_array[j] = np.trapz(dL_array, radius)  # thust produced at given azimuthal location

    dOPM_array[j] = np.trapz(dP_array, radius)  # pitching moment at given azimuthal location

    dORM_array[j] = np.trapz(dR_array, radius)  # rolling moment at given azimuthal location

    dOQi_array[j] = np.trapz(dQi_array, radius)  # induced torque at given azimuthal location                                              #filling in  corresponding array
    dOQo_array[j] = np.trapz(dQo_array, radius)  # profile torque at given azimuthal location

    dOPi_array[j] = np.trapz(dPi_array, radius)  # induced power at given azimuthal location
    dOPo_array[j] = np.trapz(dPo_array, radius)  # profile power at given azimuthal location
    # print("\u03A8 :",float32(psi_array[j]*(180/pi)),"  dT:",dT_array[j],"  dPM:",dOPM_array[j],"   dRM:",dORM_array[j])

#circulation[:,IM-1],circulation[:,0]= 0,0
THRUST = np.trapz(dT_array, psi_array) * (b / (2 * pi))  # thust produced at given azimuthal location

OVERALL_PITCHING_MOMENT = np.trapz(dOPM_array, psi_array) * (b / (2 * pi))   # Overall Pitching Moment produced by rotor
OVERALL_ROLLING_MOMENT = np.trapz(dORM_array, psi_array) * (b / (2 * pi))  # Overall Rolling Moment produced by rotor
INDUCED_TORQUE = np.trapz(dOQi_array, psi_array) * (b / (2 * pi))  # Induced Torque produced by rotor
PROFILE_TORQUE = np.trapz(dOQo_array, psi_array) * (b / (2 * pi))  # Profile Torque produced by rotor

TOTAL_TORQUE = INDUCED_TORQUE + PROFILE_TORQUE  # Total Torque produced by rotor

INDUCED_POWER = np.trapz(dOPi_array, psi_array) * (b / (2 * pi))   # Induced Power produced by rotor
PROFILE_POWER = np.trapz(dOPo_array, psi_array) * (b / (2 * pi)) # Profile Power produced by rotor
TOTAL_POWER = (INDUCED_POWER) + PROFILE_POWER  # Total Power produced by rotor
#%%
x_values_BEM= np.zeros((N+1,IM))  # N is number of azimuthal divisions , IM  is number of radial divisions
y_values_BEM= np.zeros((N+1,IM))
z_values_BEM= np.zeros((N+1,IM))
for j in range(N+1):
    for i in range(IM):
        x_values_BEM[j][i],y_values_BEM[j][i] = Rotate_for_plot(0,radius[i]/R_tip, -j*dpsi) # dpsi is (360/(N-1))*(pi/180)  ,in radians , R_tip is tip radius

z_values_BEM[:, :] = Thrust_plot_array[:, :]
z_values_BEM[N,:] = Thrust_plot_array[0, :]


#%%
print(">>>>>>>>>>>>  RESULTS  <<<<<<<<<<<<")
print("Thrust at Trim condition (N):", round(THRUST, 3))
print("Overall Pitching Moment (Nm):", round(OVERALL_PITCHING_MOMENT, 3))
print("Overall Rolling Moment (Nm):", round(OVERALL_ROLLING_MOMENT, 3))
print("Induced Torque (Nm):", round(INDUCED_TORQUE, 3))
print("Profile Torque (Nm):", round(PROFILE_TORQUE, 3))
print("Total Torque (Nm):", round(TOTAL_TORQUE, 3))
print("Induced Power (kW):", round(INDUCED_POWER * 0.001,3))
print("Profile Power (kW):", round(PROFILE_POWER * 0.001, 3))
print("Total Power (kW):", round(TOTAL_POWER * 0.001, 3))

CT = THRUST / (rho * Disc_Area * (omega * R_tip) ** 2)  # Thrust co efficient #""";
CP = TOTAL_POWER / (rho * Disc_Area * (omega * R_tip) ** 3)  # Thrust co efficient #""";
print("ThrustA2: {} N and CT: {}".format(round(Thrust, 3), CT_A1))
print("PowerA2: {} kW and CP: {}".format(round(0.001*Power, 3), CP))
print("Thrust: {} N and CT: {}".format(round(THRUST, 3), CT))
print("Power: {} kW and CP: {}".format(round(TOTAL_POWER / 1000, 3), CP))

# %%

def HoverWake(CT_input, mu_in):
    CT = CT_input/Number_of_rotors
    A = 0.78
    lam = 0.145 + 27 * CT
    Zv_array = np.zeros((JM, IM))
    array_X1 = np.zeros((JM, IM, b))
    array_Y1 = np.zeros((JM, IM, b))
    array_Z1 = np.zeros((JM, IM, b))

    array_Xn = np.zeros(JM)
    array_Yn = np.zeros(JM)
    array_Zn = np.zeros(JM)
    for i in range(IM):
        if i >= 0 and i < (IM - 1):  # trailing vortex sheet
            for j in range(JM):  # TIME LOOP
                psi = j * dpsi
                R_vortex = radius[i] * (A + (1 - A) * exp(-lam * psi))
                chord_value =chord[i]
                solidity_value = (Blades_per_turbine * chord_value) / (pi * R_tip)
                K1 = -2.2 * sqrt(0.5 * CT)
                K2 = -2.7 * sqrt(0.5 * CT)

                if psi <= ((2 * pi) / Blades_per_turbine):
                    Zv_array[j][i] = radius[i] * (K1 * psi)
                else:
                    Zv_array[j][i] = radius[i] * (K1 * ((2 * pi) / Blades_per_turbine) + K2 * (psi - ((2 * pi) / Blades_per_turbine)))

                for bn in range(1, b + 1):
                    if bn<= Blades_per_turbine:
                        array_X1[j][i][bn - 1], array_Y1[j][i][bn - 1] = Rotate(R_vortex, 0, 1*psi + ((bn - 1) / Blades_per_turbine) * 2 * pi)
                        array_X1[j][i][bn - 1] = array_X1[j][i][bn - 1] - X_displacement
                        array_Y1[j][i][bn - 1] = array_Y1[j][i][bn - 1] - Y_displacement
                        array_Z1[:, :, bn - 1] = Zv_array +h_by_r*R_tip
                    else:
                        array_X1[j][i][bn - 1], array_Y1[j][i][bn - 1] = Rotate(R_vortex, 0, 1*psi + ((bn - 1) / Blades_per_turbine) * 2 * pi)

                        if h_by_r ==0:
                            array_Z1[:, :, bn - 1] = Zv_array+ Z_displacement
                        else:
                            array_Z1[:, :, bn - 1] = np.multiply(Zv_array, -1) - h_by_r * R_tip

        if i == (IM - 1):  # Tip vortex
            for j in range(JM):  # TIME LOOP
                psi = j * dpsi
                R_vortex = radius[i] * (A + (1 - A) * exp(-lam * psi))
                chord_value = chord[i]
                solidity_value = (Blades_per_turbine * chord_value) / (pi * R_tip)

                K1 = -0.25 * ((CT / solidity_value) + 0.001 * blade_twist * (180 / pi))

                K2 = -(1.41 + 0.0141 * blade_twist * (180 / pi)) * sqrt(0.5 * CT)

                if psi <= ((2 * pi) / Blades_per_turbine):
                    Zv_array[j][i] = radius[i] * (K1 * psi)
                else:
                    Zv_array[j][i] = radius[i] * (K1 * ((2 * pi) / Blades_per_turbine) + K2 * (psi - ((2 * pi) / Blades_per_turbine)))

                for bn in range(1, b + 1):
                    if bn<= Blades_per_turbine:
                        array_X1[j][i][bn - 1], array_Y1[j][i][bn - 1] = Rotate(R_vortex, 0, 1*psi + ((bn - 1) / Blades_per_turbine) * 2 * pi)
                        array_X1[j][i][bn - 1]= array_X1[j][i][bn - 1]- X_displacement
                        array_Y1[j][i][bn - 1]= array_Y1[j][i][bn - 1]- Y_displacement
                        array_Z1[:, :, bn - 1] = Zv_array +h_by_r*R_tip
                    else:
                        array_X1[j][i][bn - 1], array_Y1[j][i][bn - 1] = Rotate(R_vortex, 0, 1*psi + ((bn - 1) / Blades_per_turbine) * 2 * pi)


                        if h_by_r ==0:
                            array_Z1[:, :, bn - 1] = Zv_array+ Z_displacement
                        else:
                            array_Z1[:, :, bn - 1] = np.multiply(Zv_array, -1) - h_by_r * R_tip


    return array_Y1, array_X1, array_Z1  #########

# %%


array_Xprs, array_Yprs, array_Zprs = HoverWake(CT, mu)

Positions_compare = np.zeros((JM, IM, 3, b))
for j in range(JM):
    for i in range(IM):
        Positions_compare[j, i, 0, 0], Positions_compare[j, i, 1, 0] = Rotate(array_Xprs[j, i, 0], array_Yprs[j, i, 0], -1 * dpsi)
        Positions_compare[j, i, 2, 0] = array_Zprs[j, i, 0]

array_Xprsnr, array_Yprsnr, array_Zprsnr = np.divide(array_Xprs, R_tip), np.divide(array_Yprs, R_tip), np.divide(array_Zprs, R_tip)
#%%
# mlab.figure(1)
# for bl in range(0,b):
#     x, y, z = array_Xprsnr[:, :, bl], array_Yprsnr[:, :, bl], array_Zprsnr[:, :, bl]
#     s = mlab.mesh(x, y, z)
#     mlab.plot3d(array_Xprsnr[:, IM - 1, bl], array_Yprsnr[:, IM - 1, bl], array_Zprsnr[:, IM - 1, bl])
# mlab.show()
#%%

# %%
# @numba.njit
def EX2BMethod():
    Positions_OLD = np.zeros((JM, IM, 3, b))

    Positions_NEW = np.zeros((JM, IM, 3, b))

    Positions_PC = np.zeros((JM, IM, 3, b))

    Blade_positions = np.zeros((IM, IM, 3, b))

    Positions_compare = np.zeros((JM, IM, 3, b))

    Positions_OLD[:, :, 0, :] = array_Xprs
    Positions_OLD[:, :, 1, :] = array_Yprs
    Positions_OLD[:, :, 2, :] = array_Zprs


    Positions_PC[:, :, 0, :] = array_Xprs
    Positions_PC[:, :, 1, :] = array_Yprs
    Positions_PC[:, :, 2, :] = array_Zprs

    Positions_compare[:] = Positions_OLD

    C_psi = 0
    RMS_array = []
    Power_array_iter = []
    Thrust_array_iter = []

    rms_change = 1
    Rotation_count = 0
    rotation = 0
    count = 0
    az_index = 0
    shed_index = 1
    dbeta_dt = 0
    beta = 0
    Azimuthal_dT_array = np.zeros((N,b))
    Azimuthal_dOPi_array = np.zeros((N,b))
    Azimuthal_dOPo_array = np.zeros((N,b))
    Azimuthal_PM_array = np.zeros((N,b))
    Azimuthal_RM_array = np.zeros((N,b))
    Azimuthal_dOQo_array = np.zeros((N,b))
    Azimuthal_dOQi_array = np.zeros((N,b))
    V_IND = np.zeros((JM, 3, 3, blades))
    CirVM_array = np.zeros((JM+1,IM+1, b,2))
    Thrust_contours = np.zeros((JM, IM , b, 2))

    Shed_circulation = np.zeros((JM, IM+1, b, 2))
    Trail_circulation = np.zeros((JM, IM +1, b, 2))

    for bc in range(1,b+1):
        for ic in range(IM):
            CirVM_array[:JM,ic, bc-1,0] = circulation[:,ic]
            CirVM_array[:JM,ic, bc-1, 1] = circulation[:,ic]

    Trail_circulation[:, 0:IM, :, :] = CirVM_array[:JM, 0:IM, :, :] - CirVM_array[:JM, 1:, :, :]
    Blade_Velocities = np.zeros((IM, 3, b))
    Up_VM_array = np.zeros((N, IM))
    while rms_change > 0.01:
        count = count + 1
        rotation = rotation + dpsi * (180 / pi)
        C_psi = C_psi + 1
        Radial_dT_array = np.zeros((IM,b))
        Radial_dOPi_array = np.zeros((IM,b))
        Radial_dOPo_array = np.zeros((IM,b))
        Radial_PM_array = np.zeros((IM,b))
        Radial_RM_array = np.zeros((IM,b))
        Radial_dOQo_array = np.zeros((IM,b))
        Radial_dOQi_array = np.zeros((IM,b))

        for bl in range(1, b + 1):
            for ir in range(IM):
                if bl <= Blades_per_turbine:
                    alpha_p= -1*alpha
                    psi = (1 * count * dpsi + ((bl - 1) / Blades_per_turbine) * 2 * pi)
                    psi_p = (-1 * count * dpsi + ((bl - 1) / Blades_per_turbine) * 2 * pi)
                    Positions_NEW[0][ir][1][bl - 1] = radius[ir] * ((cos(psi_p) * cos(beta)) + sin(beta) * sin(alpha_p))
                    Positions_NEW[0][ir][0][bl - 1] = radius[ir] * (sin(psi_p) * cos(beta))
                    Positions_NEW[0][ir][2][bl - 1] = radius[ir] * (sin(beta) * cos(alpha_p) - cos(psi_p) * cos(beta) * sin(alpha_p)) +  h_by_r*R_tip


                else:
                    psi = (1 * count * dpsi + ((bl - 1) / Blades_per_turbine) * 2 * pi)
                    psi_p = (1 * count * dpsi + ((bl - 1) / Blades_per_turbine) * 2 * pi)
                    Positions_NEW[0][ir][1][bl - 1] = 1 * X_displacement + radius[ir] * ((cos(psi_p) * cos(beta)) + sin(beta) * sin(alpha_p))
                    Positions_NEW[0][ir][0][bl - 1] = 1 * Y_displacement + radius[ir] * (sin(psi_p) * cos(beta))
                    Positions_NEW[0][ir][2][bl - 1] = array_Zprs[0][ir][bl - 1] + radius[ir] * (sin(beta) * cos(alpha_p) - cos(psi_p) * cos(beta) * sin(alpha_p))

                V_ind_geometry = np.zeros((JM, 3))
                V_IND[:, :, 0, bl - 1] = Biot_Savarts_Law2(Positions_OLD, Trail_circulation[:, :, :, 0], Shed_circulation[:,:,:,0],bl - 1, ir, V_ind_geometry)

                Positions_NEW[1:, ir, :, bl - 1] = Positions_OLD[0:JM - 1, ir, :, bl - 1] + (dpsi / omega) * (V_INF[1:, :] + (1 / 3) * (V_IND[1:, :, 0, bl - 1] + V_IND[1:, :, 1, bl - 1] + V_IND[1:, :, 2, bl - 1]))

                V_ind_performance = np.zeros(3)
                Blade_Velocities[ir, :, bl - 1] = Biot_Savarts_Perfromance(Positions_OLD, Trail_circulation[:, :, :, 0],Shed_circulation[:,:,:,0], bl - 1, ir, V_ind_performance)
                V_IND[:, :, 2, bl - 1] = V_IND[:, :, 1, bl - 1]
                V_IND[:, :, 1, bl - 1] = V_IND[:, :, 0, bl - 1]

                theta_equation = (theta[ir] + theta_1c * cos(psi) + theta_1s * sin(psi))

                Up = abs( Blade_Velocities[ir, 2, bl - 1] ) + u_inf * sin(alpha) + u_inf * sin(beta) * cos(psi) #-abs(Vv*(1+sin(10*psi)))
                #Up = PTC_inflow_array[ir] * omega * R_tip + u_inf * sin(alpha) + u_inf * sin(beta) * cos(psi)  # -abs(Vv*(1+sin(10*psi)))

                Ut = omega * radius[ir] + u_inf * cos(alpha) * sin(psi)
                Up_VM_array[az_index][ir] = Up

                L_bar = 0.5 * rho * chord[ir] * a * (theta_equation - atan(abs(Up) / Ut))*(Up**2 + Ut**2)  # filling the  corresponding array

                dDi = 0.5 * rho * chord[ir] * a * (theta_equation - atan(Up / Ut)) * Up * Ut  # Di term in induced torque equation
                dDo = 0.5 * rho * Ut * Ut * chord[ir] * (Cdo)  # Do term in  profile torque equation
                dQi = dDi * radius[ir]
                dQo = dDo * radius[ir]
                dRM = L_bar * radius[ir] * sin(abs(psi))
                dPM = 1 * L_bar * radius[ir] * cos(psi)

                CirVM_array[1:JM, ir, bl - 1, 1] = CirVM_array[0:JM-1, ir, bl - 1, 1]

                CirVM_array[0, ir, bl - 1, 1] = CirVM_array[0, ir, bl - 1, 0]+ 0.1*(abs(L_bar / (rho * Ut))-CirVM_array[0, ir, bl - 1, 0])

                Thrust_contours[1:JM, ir, bl - 1, 1] = Thrust_contours[0:JM - 1, ir, bl - 1, 1]
                Thrust_contours[0, ir, bl - 1, 1]= L_bar

                Shed_circulation[0:JM, ir, bl - 1, 1] = CirVM_array[0:JM , ir, bl - 1, 1] - CirVM_array[0:JM , ir, bl - 1, 0]

                Trail_circulation[2:JM, ir, bl - 1, 1]=Trail_circulation[1:JM-1,  ir, bl - 1, 1]
                Trail_circulation[1,  ir, bl - 1, 1] = CirVM_array[0,  ir, bl - 1, 1] - CirVM_array[0,  ir+1, bl - 1, 1]

                Trail_circulation[0,  ir, bl - 1, 1]= CirVM_array[0, ir, bl - 1, 1]
                dPi = dDi * Ut  # filling the  corresponding array
                dPo = dDo * Ut

                Radial_dT_array[ir][bl-1] =    L_bar
                Radial_dOPi_array[ir][bl-1] =  dPi
                Radial_dOPo_array[ir][bl-1] =  dPo

                Radial_dOQi_array[ir][bl-1] = dQi
                Radial_dOQo_array[ir][bl-1] =  dQo
                Radial_PM_array[ir][bl-1] =    dPM
                Radial_RM_array[ir][bl-1] =   dRM

        Positions_OLD[:] = Positions_NEW

        for bx in range(1, b + 1):
            Azimuthal_dT_array[az_index,bx-1] =   np.trapz(Radial_dT_array[:,bx-1], radius) * (1 / (2 * pi))
            Azimuthal_dOPi_array[az_index,bx-1] = np.trapz(Radial_dOPi_array[:,bx-1], radius) * (1 / (2 * pi))
            Azimuthal_dOPo_array[az_index,bx-1] = np.trapz(Radial_dOPo_array[:,bx-1], radius)* (1 / (2 * pi))
            Azimuthal_dOQi_array[az_index,bx-1] = np.trapz(Radial_dOQi_array[:,bx-1], radius)* (1 / (2 * pi))
            Azimuthal_dOQo_array[az_index,bx-1] = np.trapz(Radial_dOQo_array[:,bx-1], radius)* (1 / (2 * pi))
            Azimuthal_PM_array[az_index,bx-1] =  np.trapz(Radial_PM_array[:,bx-1], radius)* (1 / (2 * pi))
            Azimuthal_RM_array[az_index,bx-1] =  np.trapz(Radial_RM_array[:,bx-1], radius)* (1 / (2 * pi))

        CirVM_array[:,:,:,0] = CirVM_array[:,:,:,1]
        Shed_circulation[:, :, :, 0] = Shed_circulation[:, :, :, 1]
        Trail_circulation[:, :, :, 0] = Trail_circulation[:, :, :, 1]
        Thrust_contours[:, :, :, 0] = Thrust_contours[:, :, :, 1]


        az_index = az_index + 1

        if (C_psi % N) == 0:
            # print("HI")
            Rotation_count += 1
            Change_array = Positions_NEW[:, IM - 1, :, b-1] - Positions_compare[:, IM - 1, :,  b-1]
            dx2_dy2_dz2 = np.square(Change_array)
            dx2_dy2_dz2_sum = dx2_dy2_dz2[:, 0] + dx2_dy2_dz2[:, 1] + dx2_dy2_dz2[:, 2]
            # Eucladian_distance= np.sqrt(dx2_dy2_dz2[:,0]+ dx2_dy2_dz2[:,1]+dx2_dy2_dz2[:,2])
            shift_sum = np.sum(dx2_dy2_dz2_sum)
            err1 = sqrt((shift_sum) / JM)
            rms_change = err1 / R_tip
            RMS_array.append(rms_change)
            Thrust_new = np.zeros(int(Number_of_rotors))
            Induced_Power = np.zeros(int(Number_of_rotors))
            Profile_Power =np.zeros(int(Number_of_rotors))
            Power_new = np.zeros(int(Number_of_rotors))
            Torque_new = np.zeros(int(Number_of_rotors))
            OPM_new = np.zeros(int(Number_of_rotors))
            ORM_new =np.zeros(int(Number_of_rotors))


            for by in range(1,b+1):
                if by <= Blades_per_turbine:
                    nx=0
                    Thrust_new[nx] =Thrust_new[nx]+ np.trapz(Azimuthal_dT_array[:,by-1], psi_array)
                    Induced_Power[nx]=Induced_Power[nx]+ (np.trapz(Azimuthal_dOPi_array[:,by-1], psi_array))
                    Profile_Power[nx]= Profile_Power[nx]+  (np.trapz(Azimuthal_dOPo_array[:,by-1], psi_array))
                    Power_new[nx] = Power_new[nx]+ ((np.trapz(Azimuthal_dOPi_array[:,by-1], psi_array))  + (np.trapz(Azimuthal_dOPo_array[:,by-1], psi_array)))
                    Torque_new[nx]= Torque_new[nx]+ ((np.trapz(Azimuthal_dOQi_array[:,by-1], psi_array)) + np.trapz(Azimuthal_dOQo_array[:,by-1], psi_array))
                    OPM_new[nx]= OPM_new[nx]+ np.trapz(Azimuthal_PM_array[:,by-1], psi_array)
                    ORM_new[nx]=  ORM_new[nx]+ np.trapz(Azimuthal_RM_array[:,by-1], psi_array)
                else:
                    nx=1
                    Thrust_new[nx] =Thrust_new[nx]+ np.trapz(Azimuthal_dT_array[:,by-1], psi_array)
                    Induced_Power[nx]=Induced_Power[nx]+ (np.trapz(Azimuthal_dOPi_array[:,by-1], psi_array))
                    Profile_Power[nx]= Profile_Power[nx]+  (np.trapz(Azimuthal_dOPo_array[:,by-1], psi_array))
                    Power_new[nx] = Power_new[nx]+ ((np.trapz(Azimuthal_dOPi_array[:,by-1], psi_array))  + (np.trapz(Azimuthal_dOPo_array[:,by-1], psi_array)))
                    Torque_new[nx]= Torque_new[nx]+ ((np.trapz(Azimuthal_dOQi_array[:,by-1], psi_array)) + np.trapz(Azimuthal_dOQo_array[:,by-1], psi_array))
                    OPM_new[nx]= OPM_new[nx]+ np.trapz(Azimuthal_PM_array[:,by-1], psi_array)
                    ORM_new[nx]=  ORM_new[nx]+ np.trapz(Azimuthal_RM_array[:,by-1], psi_array)


            Azimuthal_dT_array = np.zeros((N, b))
            Azimuthal_dOPi_array = np.zeros((N, b))
            Azimuthal_dOPo_array = np.zeros((N, b))
            Azimuthal_PM_array = np.zeros((N, b))
            Azimuthal_RM_array = np.zeros((N, b))
            Azimuthal_dOQo_array = np.zeros((N, b))
            Azimuthal_dOQi_array = np.zeros((N, b))


            print(Rotation_count, round(rms_change,5), round(np.sum(Thrust_new),3), round(np.sum(Induced_Power * 0.001),3), round(np.sum(Profile_Power * 0.001),3),round(np.sum(Power_new* 0.001),3), round(np.sum(Torque_new) ,2),round(np.sum(OPM_new) ,2), round(np.sum(ORM_new),2))
            Positions_compare[:] = Positions_NEW

            az_index = 0

            # mlab.figure(5)
            # for bl in range(0, b):
            #     x, y, z = Positions_NEW[:, 3:, 0, bl], Positions_NEW[:, 3:, 1, bl], Positions_NEW[:, 3:, 2, bl]
            #     s = mlab.mesh(x, y, z)
            #     mlab.plot3d(Positions_NEW[:, IM - 1, 0, bl], Positions_NEW[:, IM - 1, 1, bl], Positions_NEW[:, IM - 1, 2, bl])
            # mlab.show()

        if Rotation_count == N_count:
            break

    print(" Rotor Thrust  Induced Power   Profile Power Total Power")
    for nx in range(int(Number_of_rotors)):
        print(nx+1 ,round(Thrust_new[nx],3), round(Induced_Power[nx],3),round( Profile_Power[nx],3), round(Induced_Power[nx]+ Profile_Power[nx],3))
    return Positions_NEW, RMS_array, CirVM_array, Thrust_new, Power_new, Blade_Velocities,Thrust_contours,Shed_circulation,Trail_circulation,Up_VM_array


# Blade_Velocities[i,:,bl-1]= Biot_Savarts_Perfromance(Positions_NEW, CirVM_array, bl-1, i)
# Up = abs(Blade_Velocities[i,2,bl-1])+ u_inf*sin(alpha) + u_inf*sin(beta)*cos(count*dpsi)  # perpendicular velocity

# %%
print("Thrust(BEM_A2) N: {}  Power(BEM_A2) kW: {}".format(round(Thrust, 3), round(Power / (Number_of_rotors*1000), 3)))
print("Thrust(BEM_A3) N: {}  Power(BEM_A3) kW: {}".format(round(THRUST, 3), round(TOTAL_POWER / 1000, 3)))
current_time1 = time.time()
print(">>>>EX2B {}deg".format(round(dpsi_d, 2)))
print("   RMS_CHANGE   Thrust(N)  Power(kW)")
POS_EX2B, RMS_EX2B, Circ_updated, Thrust_updated, Power_updated, BV,T_Contours,Shed_filaments,Trailing_filaments,Up_VM_array = EX2BMethod()
current_time2 = time.time()
Execution_time = round(current_time2 - current_time1, 5)
print("Execution time (EX2B Method ):", Execution_time, "sec")

# plt.figure(100)
# plt.plot(UP_array)
# plt.plot(-1*BV[:,2,0])

#%%
# plt.figure(10, dpi=150)
# for bl in range(1,b+1):
#     if bl<=Blades_per_turbine:
#         plt.plot(radius / R_tip, Circ_updated[0,:IM,bl-1,0]/max(Circ_updated[0,:,bl-1,0]), label=" VM code")
#     else:
#         plt.plot(radius / (R_tip), Circ_updated[0, :IM, bl - 1, 0] / max(Circ_updated[0, :, bl - 1, 0]), label=" VM code")

plt.figure(10, dpi=150)
plt.plot(radius / R_tip, circulation[0,:], label=" BEM code")
plt.plot(radius / R_tip, Circ_updated[0,:IM,0,0], label=" Vortex Method code")

#/ max(Circ_updated[0, :, bl - 1, 0])
plt.title("Thrust Vs Radial location")
#plt.ylim(0,1.2)
plt.xlabel("r/R")
plt.ylabel("Circulation")
plt.legend()

print("Thrust(BEM): {} Power(BEM): {}".format(round(np.sum(THRUST), 3), round(np.sum(TOTAL_POWER / 1000), 3)))
print("Thrust(VM): {} Power(VM): {} ".format(round(np.sum(Thrust_updated), 3), round(np.sum(Power_updated / 1000), 3)))
Difference = abs((np.sum(Thrust_updated) - np.sum(THRUST)) / np.sum(Thrust_updated)) * 100
print(Difference)

#print(Circ_updated[:,:,0,0])
# %%
# plt.plot(RMS_PC2B[:])

# POSNr_explicit= np.divide(POS_explicit,R_tip)
# POSNr_EX2B= np.divide(POS_EX2B,R_tip)

# POSNr_explicit_E2B= np.divide(POS_explicit_E2B,R_tip)
POSNr_EX2B = np.divide(POS_EX2B, R_tip)
# POSNr_PC2B= np.divide(POS_PC2B,R_tip)

array_Xprsnr, array_Yprsnr, array_Zprsnr = np.divide(array_Xprs, R_tip), np.divide(array_Yprs, R_tip), np.divide(array_Zprs, R_tip)

# current_time1 = time.time()
# current_time2 = time.time()
# Execution_time = round(current_time2 - current_time1, 5)
# print("Execution time (EX2B Method ):", Execution_time, "sec")
# # azimuthal angle (i.e. psi) in degrees

# %%
plt.figure(3, figsize=(5, 5), dpi=150)
# plt.figure(4,dpi=150)
ax = plt.axes(projection='3d')
# ax.set_title("Tip Vortex location")
ax.set_xlabel(r'$\frac{r}{R}$', fontsize=15)
ax.set_ylabel(r'$\frac{r}{R}$', fontsize=15)
ax.set_zlabel(r'$\frac{z}{R}$', fontsize=15, rotation= 0)

# ax.set_ylim3d(-0.5*max(POS_explicit[:,0,:]),0.5*max(POS_explicit[:,0,:]))
if mu == 0:
    ax.set_xlim3d(-2, 2)
    ax.set_ylim3d(-2, 2)

if mu > 0:
    ax.set_xlim3d(-2, 2)
    ax.set_zlim3d(-2, 1)
    ax.view_init(0, 0)
for i in range(0, b):
    #plt.plot(array_Xprsnr[:, IM - 1, i], array_Yprsnr[:, IM - 1, i], array_Zprsnr[:, IM - 1, i], label='Prescibed', color='blue', marker='')

    plt.plot(POSNr_EX2B[:, IM - 1, 0, i], POSNr_EX2B[:, IM - 1, 1, i], POSNr_EX2B[:, IM - 1, 2, i], color='brown', marker='', markersize=3, linewidth=1)

    # plt.plot(POSNr_PC2B[:,IM-1,0,i],POSNr_PC2B[:,IM-1,1,i],POSNr_PC2B[:,IM-1,2,i],color='black',label='PC2B',marker='',markersize=3, linewidth=1)
plt.title(" Tip Vortex geometry at Advance ratio {}   , CT {}".format(round(mu, 3), round(CT, 3)))
ax.legend(["Free Wake model"])
plt.show()


# %%
# plt.figure(4, dpi=150)
# #plt.plot(wake_age_array, array_Zprsnr[:, IM - 1, 0], 'b-', label='Prescribed Wake')
# # plt.plot(POSNr_EX2B[:, IM - 1, 2, 0], 'r-.', label='EX2B')
# # plt.plot(POSNr_PC2B[:,IM-1,2,0],'k-.',label='PC2B')
# # plt.plot(wake_age_array, POSNr_EX2B[:, IM - 1, 2, 0], 'k', label='Lower rotor')
# plt.plot(wake_age_array, POSNr_EX2B[:, IM - 1, 2, 1], 'r', label='Lower rotor')
# # plt.plot(wake_age_array, POSNr_EX2B[:, IM - 1, 2, 2], 'g', label='Upper rotor')
# plt.plot(wake_age_array, POSNr_EX2B[:, IM - 1, 2, 3], 'b', label='Upper rotor+')
# # plt.plot(wake_age_array,POSNr_PC2B[:,IM-1,2,b-1],'r',label='PC2B')
# plt.ylabel(r'$\frac{z}{R}$',fontsize=16,rotation=0)
# plt.xlabel(r'Wake age($\zeta^o$)')
# plt.title("Axial Displacement vs Wake age")
# plt.legend()
# plt.show()
#%%
plt.figure(4, dpi=150)
#plt.plot(wake_age_array, array_Zprsnr[:, IM - 1, 0], 'b-', label='Prescribed Wake')
plt.plot(POSNr_EX2B[:, IM - 1, 2, 0], 'r-.', label='EX2B')
# plt.plot(POSNr_PC2B[:,IM-1,2,0],'k-.',label='PC2B')
plt.ylabel(r'$\frac{z}{R}$',fontsize=16,rotation=0)
plt.xlabel(r'Wake age($\zeta^o$)')
plt.title("Axial Displacement vs Wake age")
plt.legend()
plt.show()
#%%


x_values_R= np.zeros((N+1,IM,b))  # N is number of azimuthal divisions , IM  is number of radial divisions
y_values_R= np.zeros((N+1,IM,b))
z_values_R= np.zeros((N+1,IM,b))
for bl in range(1,b+1):
    for j in range(N+1):
        for i in range(IM):
            if bl <= Blades_per_turbine:
                x_values_R[j][i][bl-1],y_values_R[j][i][bl-1] = Rotate_for_plot(0,radius[i]/R_tip, 1*j*dpsi+ ((bl - 1) / Blades_per_turbine) * 2 * pi) # dpsi is (360/(N-1))*(pi/180)  ,in radians , R_tip is tip radius
            else:
                x_values_R[j][i][bl - 1], y_values_R[j][i][bl - 1] = Rotate_for_plot(0, radius[i] / R_tip, -1*j * dpsi + ((bl - 1) / Blades_per_turbine) * 2 * pi)  # dpsi is (360/(N-1))*(pi/180)  ,in radians , R_tip is tip radius

for j in range(N):
    z_values_R[j,:,:] = T_Contours[j, :, :, 0]
z_values_R[N,:,:] = T_Contours[0, :, :, 0]


# for bl in range(1,b+1):
#     plt.figure(30+ bl, figsize=(5, 5), dpi=150)
#     plt.title("Blade {}".format(int(bl)))
#     plt.contourf(x_values_R[:, :, bl - 1], y_values_R[:, :, bl - 1], z_values_R[:, :, bl - 1],10*IM,cmap='jet')
#     plt.colorbar()
#     plt.show()


#%%

# plt.figure(11, figsize=(5, 5), dpi=150)
# plt.title("Thrust distribution (in N)")
# #plt.contourf(x_values_BEM,y_values_BEM, z_values_BEM , 10*IM,cmap='jet')
# plt.contourf(x_values_R,y_values_R, z_values_R,10*IM,cmap='jet')
# plt.colorbar()
# plt.xlabel("r/R")
# plt.ylabel("r/R")
# plt.show()
#%%
r_by_R_PR=np.zeros(JM)
r_by_R_VM=np.zeros(JM)
r_by_R_PR[:]= np.sqrt(np.square(array_Xprsnr[:, IM - 1, 0])+np.square(array_Yprsnr[:, IM - 1, 0]) )
r_by_R_VM[:]= np.sqrt(np.square(POSNr_EX2B[:, IM - 1, 0, 0])+np.square(POSNr_EX2B[:, IM - 1, 1, 0]) )

plt.figure(6,dpi=150)
plt.plot(wake_age_array, r_by_R_PR, 'b-', label='Prescribed Wake')
plt.plot(wake_age_array, r_by_R_VM, 'k', label='Free Wake')
if mu==0:
    plt.ylim(0,1.2)
plt.legend()
plt.show()
#%%
# plt.figure(7, dpi=150)
# plt.plot( radius/R_tip, Up_BEM_array[0,:], 'b-', label='BEM')
# plt.plot( radius/R_tip, Up_VM_array[0,:], 'k', label='Vortex Methods')
# plt.title("Induced Velocities")
# plt.xlabel("r/R")
# plt.ylabel("Up")
# plt.legend()
# plt.show()
# %%
End_time = time.time()
print("Total Execution time:", round(End_time - Start_time, 5), 'sec')
print("Advance ratio:", mu)
print("CT_NEW:", Thrust_updated/(rho * Disc_Area * (omega * R_tip) ** 2))
# %%
mlab.figure(3)
for bl in range(0,b):
    x, y, z = POSNr_EX2B[:, 2:, 0, bl], POSNr_EX2B[:, 2:, 1, bl], POSNr_EX2B[:, 2:, 2, bl]
    s = mlab.mesh(x, y, z)
    mlab.plot3d(POSNr_EX2B[:, IM - 1, 0, bl], POSNr_EX2B[:, IM - 1, 1, bl], POSNr_EX2B[:, IM - 1, 2, bl],tube_radius=0.01)
#mlab.colorbar(orientation='vertical', nb_labels=4, label_fmt='%.1f')


# %%
xt_values= np.zeros((JM,IM))  # N is number of azimuthal divisions , IM  is number of radial divisions
yt_values= np.zeros((JM,IM))
zt_values= np.zeros((JM,IM))

xs_values= np.zeros((JM,IM))  # N is number of azimuthal divisions , IM  is number of radial divisions
ys_values= np.zeros((JM,IM))
zs_values= np.zeros((JM,IM))

xf_values= np.zeros((JM,IM))  # N is number of azimuthal divisions , IM  is number of radial divisions
yf_values= np.zeros((JM,IM))
zf_values= np.zeros((JM,IM))
for j in range(JM):
    for i in range(IM):
        xt_values[j][i]=  i*dr*5
        yt_values[j][i] = j*dpsi
        zt_values[j][i] = Trailing_filaments[j, i, 0, 0]

        xs_values[j][i]=  i*dr*5 -  IM*dr*5
        ys_values[j][i] = j*dpsi
        zs_values[j][i] = Shed_filaments[j, i, 0, 0]

        xf_values[j][i]=  i*dr*5 -  2*IM*dr*5
        yf_values[j][i] = j*dpsi
        zf_values[j][i] = Trailing_filaments[j, i, 0, 0]+ Shed_filaments[j, i, 0, 0]


# mlab.figure(4)
# st = mlab.mesh(xt_values[:], yt_values[:], zt_values[:])
# ss = mlab.mesh(xs_values[:], ys_values[:], zs_values[:])
# st = mlab.mesh(xf_values[:], yf_values[:], zf_values[:])
# mlab.plot3d(xf_values[0], yf_values[0], Circ_updated[0, :IM, b - 1, 0], tube_radius=0.2)
# %%
# mlab.figure(5)
# s = mlab.mesh(x_values_R, y_values_R, z_values_R)
mlab.show()
# %%
# %%
# %%
# %%
# %%
# %%










